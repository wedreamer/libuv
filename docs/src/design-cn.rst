
.. _design:

设计概览
===============

libuv 是跨平台支持库，最初是为 `Node.js`_ 编写的。 它是围绕事件驱动的异步 I/O 模型设计的。

.. _Node.js: https://nodejs.org

该库提供的不仅仅是对不同 I/O 轮询机制的简单抽象: "句柄" 和 "流" 为套接字和其他实体提供高级抽象;
还提供了跨平台文件 I/O 和线程功能, 以及其他。

这是一个图表，说明了组成 libuv 的不同部分以及它们相关的子系统:

.. image:: static/architecture.png
    :scale: 75%
    :align: center


Handles and requests
^^^^^^^^^^^^^^^^^^^^

libuv 结合事件循环为用户提供了 2 个可以使用的抽象:
handles and requests.

handles 表示能够在活动时执行某些操作的长期对象。 一些例子:

- 准备句柄在活动时每次循环迭代都会调用一次回调.
- 每次有新连接时都会调用其连接回调的 TCP 服务器句柄.

请求代表（通常）短暂的操作。 这些操作可以在句柄上执行: 写请求用于在句柄上写入数据； 或独立: getaddrinfo 请求不需要它们直接在循环上运行的句柄.


The I/O loop
^^^^^^^^^^^^

I/O(或事件)循环是 libuv 的核心部分。 它为所有 I/O 操作建立内容，并且它被绑定到单个线程。 只要每个事件循环在不同的线程中运行，就可以运行多个事件循环。 libuv 事件循环 (或任何其他涉及循环或句柄的 API) **不是线程安全的**，除非另有说明.

事件循环遵循相当常见的单线程异步 I/O 方法: 所有(网络) I/O 都在非阻塞套接字上执行, 这些套接字使用给定平台上可用的最佳机制进行轮询: Linux 上的 epoll, OSX 上的 kqueue 和 其他 BSD、SunOS 上的事件端口和 Windows 上的 IOCP。 作为循环迭代的一部分，循环将阻塞等待已添加到轮询器的套接字上的 I/O 活动，并且将触发回调以指示套接字条件（可读、可写挂断），以便句柄可以读取、写入或执行所需的 I/O /O 操作.

为了更好地理解事件循环是如何运作的，下图说明了循环迭代的所有阶段:

.. image:: static/loop_iteration.png
    :scale: 75%
    :align: center


#. "现在" 的循环概念已更新。 事件循环在事件循环开始时缓存当前时间，以减少与时间相关的系统调用次数.

#. 如果循环是 *alive* 则开始迭代，否则循环将立即退出。 那么，什么时候循环被认为是 *活动的*? 如果循环具有活动和引用句柄、活动请求或关闭句柄，则认为它是 *活动的*.

#. 到期计时器运行。 在循环的 *now* 概念之前的某个时间安排的所有活动计时器都会调用它们的回调.

#. 挂起的回调被调用。 在大多数情况下，在轮询 I/O 之后立即调用所有 I/O 回调。 但是，在某些情况下，调用此类回调会延迟到下一次循环迭代。 如果之前的迭代延迟了任何 I/O 回调，它将在此时运行.

#. 调用空闲句柄回调。 尽管名字很不幸，但如果空闲句柄处于活动状态，则在每次循环迭代时都会运行它们.

#. 调用准备句柄回调。 准备句柄在循环阻塞 I/O 之前调用它们的回调.

#. 计算轮询超时。 在阻塞 I/O 之前，循环会计算它应该阻塞多长时间。 这些是计算超时时的规则:

        * 如果循环使用 ``UV_RUN_NOWAIT`` 标志运行，则超时为 0.
        * 如果要停止循环(调用了:c:func:`uv_stop`), 则超时为0.
        * 如果没有活动句柄或请求，则超时为 0.
        * 如果有任何空闲句柄处于活动状态，则超时为 0.
        * 如果有任何待关闭的句柄，则超时为 0.
        * 如果以上情况都不匹配，则取最近的定时器的超时时间，或者如果没有活动的定时器，无穷大.

#. I/O 的循环块。 此时，循环将在上一步计算的持续时间内阻塞 I/O。 正在监视给定文件描述符的读取或写入操作的所有 I/O 相关句柄在此时调用其回调.

#. 调用检查句柄回调。 检查句柄在循环阻塞 I/O 后立即调用它们的回调。 检查句柄本质上是准备句柄的对应物.

#. 关闭回调被调用。 如果通过调用 :c:func:`uv_close` 关闭句柄，它将调用关闭回调.

#. 特殊情况下循环使用 `UV_RUN_ONCE` 运行，因为它意味着前进。 可能在阻塞 I/O 后没有触发任何 I/O 回调，但是已经过去了一段时间，所以可能会有计时器到期，这些计时器会调用它们的回调.

#. 迭代结束。 如果循环以 `UV_RUN_NOWAIT` 或 `UV_RUN_ONCE` 模式运行，则迭代结束并且 :c:func:`uv_run` 将返回。 如果循环是用 ``UV_RUN_DEFAULT`` 运行的，如果它仍然 *alive*，它将从头开始继续，否则它也会结束.


.. important::
    libuv 使用线程池使异步文件 I/O 操作成为可能，但网络 I/O **总是** 在单个线程中执行，每个循环的线程.

.. note::
    虽然轮询机制不同，但 libuv 使执行模型在 Unix 系统和 Windows 之间保持一致.


File I/O
^^^^^^^^

与网络 I/O 不同, libuv 没有可以依赖的特定于平台的文件 I/O 原语，因此当前的方法是在线程池中运行阻塞文件 I/O 操作.

有关跨平台文件 I/O 格局的详细说明，请查看
`this post <https://blog.libtorrent.org/2012/10/asynchronous-disk-io/>`_.

libuv 当前使用一个全局线程池，所有循环都可以在其中排队工作。 当前在此池上运行 3 种类型的操作:

    * 文件系统操作
    * DNS 函数(getaddrinfo 和 getnameinfo)
    * 用户通过 :c:func:`uv_queue_work` 指定的代码

.. warning::
    有关更多详细信息，请参阅 :c:ref:`threadpool` 部分，但请记住线程池大小非常有限.
